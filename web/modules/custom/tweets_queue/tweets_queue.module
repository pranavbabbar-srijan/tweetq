<?php

/**
 * @file 
 *   To handle the custom functionality which includes -
 *   - Hooks alteration
 *   - Web services
 */

use Drupal\node\Entity\Node;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Drupal\Core\Form\ConfigFormBase;

const CONSUMER_KEY = 'consumer_key';
const CONSUMER_SECRET_KEY = 'consumer_secret_key';
const ACCESS_TOKEN = 'access_token';
const ACCESS_SECRET_TOKEN = 'access_secret_token';
const SUCCESS_MESSAGE = 'Message tweeted successfully.';
const UNSUCCESS_MESSAGE = 'Message tweet failed.';
const CRON_TWEET_ATTEMP = 'cron_tweet_attempt';
const CRON_TWEET_IMPORT_ID = 'cron_tweet_import_id';
const CRON_TWEET_IMPORT_PATH = 'cron_tweet_import_path';
const CRON_TWEET_IMPORT_FID = 'cron_tweet_import_fid';
const IMPORT_CONFIGURATION = 'import_configuration';
const TWEET_QUEUE_CSV_FILE_UPLOAD = 'tweet_queue_csv_file_upload';
const TWEET_QUEUE_CSV_FILE_UPLOAD_DIRECTORY = 'public://tweets_queue/';
const TWEETS_PRIORITY_TABLE = 'tweets_priority';
const TWEETS_URL_TABLE = 'tweets_url';
const TWEETS_HANDLER_TABLE = 'tweets_handler';
const CRON_TWEET_MIN_INTERVAL = 'cron_tweet_min_interval';
const CRON_TWEET_MAX_INTERVAL = 'cron_tweet_max_interval';
const CRON_TWEET_RETWEET_INTERVAL = 'cron_tweet_retweet_interval';
const CRON_TWEET_NEXT_RUN = 'cron_tweet_next_run';
const CRON_TWEET_LAST_RUN = 'cron_tweet_last_run';
const CRON_TWEET_DEBUG_INFO = 'cron_tweet_debug_info';
const CRON_TWEET_MESSAGES_SKIPPED = 'Tweet message skipped';


/**
 * Implements hook_form_alter().
 */
function tweets_queue_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
}

/**
 * Post the message on the twitter.
 *
 * @param string $message
 *   Message for the tweet.
 *
 * @return string
 *   Returns the tweets message.
 */
function tweets_queue_set_single_post($message = 'Good Evening!!') {
  require_once   './libraries/codebird-php/codebird.php';
  $status = array('success' => 0, 'message' => 'unsuccessful');
  $consumer_key = tweets_queue_get_tweet_configuration_data(CONSUMER_KEY);
  $consumer_secret_key = tweets_queue_get_tweet_configuration_data(CONSUMER_SECRET_KEY);
  $access_token = tweets_queue_get_tweet_configuration_data(ACCESS_TOKEN);
  $access_secret_token = tweets_queue_get_tweet_configuration_data(ACCESS_SECRET_TOKEN);

  \Codebird\Codebird::setConsumerKey($consumer_key, $consumer_secret_key);
  $cb = \Codebird\Codebird::getInstance();
  $cb->setToken($access_token, $access_secret_token);
  $params = array(
    'status' => $message
  );
  $reply = $cb->statuses_update($params);
  if (is_object($reply) && isset($reply->errors)) {
    $status['success'] = 0;
    $status['code'] = (isset($reply->errors[0]->code)) ? $reply->errors[0]->code : '';
    $status['message'] = (isset($reply->errors[0]->message)) ? $reply->errors[0]->message: 'tweet failed.';
    return $status;
  }
  if (is_object($reply)) {
    $status = array('success' => 1, 'message' => 'successful');
  }
  return $status;
}

/**
 * Implements hook_cron().
 */
function tweets_queue_cron() {
  $config = \Drupal::config('tweets_queue.settings');
  $current_time = time();
  $next_run = intval($config->get(CRON_TWEET_NEXT_RUN));
  if ($current_time >= $next_run) {
    tweets_queue_debug_info('Starting Cron tweet process');
    tweets_queue_compile_tweets('', TRUE);
  }
}

/**
 * Tweet the message.
 */
function tweets_queue_compile_tweets($message = '', $cron = FALSE) {
  $status = array();
  switch ($cron) {
    case TRUE:
      $status = tweets_queue_tweet_cron_message();
      break;
    case FALSE:
      $status = tweets_queue_tweet_message($message);
      break;
  }
  switch ($status['success']) {
    case '1':
      drupal_set_message(t(SUCCESS_MESSAGE));
      break;
    case '0':
      drupal_set_message(t(UNSUCCESS_MESSAGE));
      break;
  }
}

/**
 * Tweet the message for the cron run.
 * For the cron run, messages are tried until hits max attempt.
 *
 * @return array
 *   Status for the tweet.
 */
function tweets_queue_tweet_cron_message() {
  $status = array('success' => 0);
  $text_size = 140;
  $nids = tweets_queue_get_tweets_cron_list();
  $tweet_max_attempt = tweets_queue_get_tweet_configuration_data(CRON_TWEET_ATTEMP);
  $total = count($nids);
  tweets_queue_debug_info("Process started for $total items");
  if ($tweet_max_attempt > $total) {
    $tweet_max_attempt = $total;
  }
  for ($attempt=0; $attempt < $tweet_max_attempt; $attempt++) {
    $nid = array_rand($nids, 1);
    unset($nids[$nid]);
    $message  = tweets_queue_load_tweet_message($nid);
    $tweet_size = \Drupal\Component\Utility\Unicode::strlen($message);
    tweets_queue_debug_info("Process progress for $nid:$message::size:$tweet_size");
    if ($tweet_size > $text_size) {
      tweets_queue_debug_info(t(':message for :nid',
        array(':message' => CRON_TWEET_MESSAGES_SKIPPED, ':nid' => $nid)));
      tweets_queue_update_priority($nid);
      continue;
    }
    if (!tweets_queue_authenticate_url($message)) {
      tweets_queue_debug_info('Tweet from same article already exists.');
      tweets_queue_debug_info(t(':message for :nid',
        array(':message' => CRON_TWEET_MESSAGES_SKIPPED, ':nid' => $nid)));
      // tweets_queue_update_priority($nid);
      continue;
    }
    tweets_queue_debug_info("Process Send started.");
    $status = tweets_queue_tweet_message($message);
    tweets_queue_update_priority($nid);
    tweets_queue_update_url($message);
    if ($status['success']) {
      tweets_queue_schedule_cron(0);
      return $status;
    }
  }
  if ($attempt >= $tweet_max_attempt-1) {
    // tweets_queue_schedule_cron(1);
    drupal_set_message(t('Maximun tweet attempt reached.'));
  }
  return $status;
}

/**
 * Test whether text contains url and passed execution time line.
 *
 * @param string $message
 * @return integer
 */
function tweets_queue_authenticate_url($message) {
  $tweet_allowed = 1;
  $tweet_disallowed = 0;
  preg_match_all('#\bhttps?://[^,\s()<>]+(?:\([\w\d]+\)|([^,[:punct:]\s]|/))#', $message, $match);
  if ($match[0][0] == '') {
    return $tweet_allowed;
  }
  $url = $match[0][0];
  $query = \Drupal::database()->select(TWEETS_URL_TABLE, 'p');
  $query->addField('p', 'last_run');
  $query->condition('p.path', $url);
  $last_run = $query->execute()->fetchField();
  if ($last_run == 0 or $last_run == '') {
    return $tweet_allowed;
  }
  $minimum_lapse_interval = tweets_queue_get_tweet_configuration_data(CRON_TWEET_RETWEET_INTERVAL);
  $next_reweet = $last_run + $minimum_lapse_interval;
  $now = time();
  if ($next_reweet <= $now) {
    return $tweet_allowed;;
  }
  tweets_queue_debug_info(t("Same article tweet was last run at :last_run",
    array(':last_run' => $last_run)));
  tweets_queue_debug_info(t("Next run time is :next_reweet",
    array(':next_reweet' => $next_reweet)));
  return $tweet_disallowed;
}

/**
 * Tweet the message.
 *
 * @param string $message
 *   Message to be tweeted.
 *
 * @return array
 *   Status for the tweet.
 */
function tweets_queue_tweet_message($message) {
  $status = array('success' => 0);
  if (empty($message)) {
    return $status;
  }
  try {
    $status = tweets_queue_set_single_post($message);
  }
  catch (\Exception $e) {
    \Drupal::logger('tweets_queue')->error($e->getMessage());
    drupal_set_message(t($e->getMessage()));
  }
  return $status;
}

/**
 * Get the tweet message stored in the database.
 *
 * @return string
 *   Returns the tweets message.
 */
function tweets_queue_get_tweets_cron_list() {
  $nid = '';
  $message = '';
  $minimum_lapse_interval = tweets_queue_get_tweet_configuration_data(CRON_TWEET_RETWEET_INTERVAL);
  $query = \Drupal::database()->select(TWEETS_PRIORITY_TABLE, 'p');
  $query->fields('p', ['nid']);

  if ($minimum_lapse_interval > 0) {
    $minimum_lapse_time = time() - ($minimum_lapse_interval * 60);
    $db_or = db_or();
    $db_or->condition('p.last_run', '0' , '=');
    $db_or->condition('p.last_run', $minimum_lapse_time , '<=');
    $query->condition($db_or);
  }

  $query->orderBy('p.weight', 'ASC');
  $query->range(0, 10);
  $nids = $query->execute()->fetchAllKeyed();
  return $nids;
}

/**
 * Load the tweet message for the tweeting.
 *
 * @param integer $nid
 *   Entity nid.
 *
 * @return string
 *   Returns the tweets message.
 */
function tweets_queue_load_tweet_message($nid = '') {
  $message = '';
  if (empty($nid)) {
    return $message;
  }
  $entity  = Node::load($nid);
  if (is_object($entity)) {
    $title = tweets_queue_load_field_info($entity, 'title');
    $body = tweets_queue_load_field_info($entity, 'body');
    $hash_tag = tweets_queue_load_field_info($entity, 'field_hash_tag');
    $message = $title . ' ' . $body . ' ' . $hash_tag;
  }
  return $message;
}

/**
 * Fetch field data from the entity..
 *
 * @param object $entity
 *   Entity object.
 *
 * @param string $field_name
 *   Name of the entity field to be read.
 *
 * @return string
 *   Returns the tweets message for the tweeting.
 */
function tweets_queue_load_field_info($entity, $field_name = 'title') {
  $output = '';
  $field_info = $entity->get($field_name)->getValue();
  if (count($field_info) > 0) {
    foreach ($field_info as $pos => $field_value) {
      $data = ($data) ? $data . ' ' . $field_value['value'] : $field_value['value'];
    }
  }
  return $data;
}

/**
 * Get tweets api configuration data.
 * This data is used to for tweets authentication.
 *
 * @param string $key
 *  Name of the tweets api configuration name.
 *
 * @return string
 *   Returns the tweets api configuration data.
 */
function tweets_queue_get_tweet_configuration_data($key = CONSUMER_KEY) {
  $config = \Drupal::config('tweets_queue.settings');
  $data = '';
  switch ($key) {
    case ACCESS_TOKEN:
      $data = $config->get(ACCESS_TOKEN);
      break;
    case ACCESS_SECRET_TOKEN:
      $data = $config->get(ACCESS_SECRET_TOKEN);
      break;
    case CONSUMER_KEY:
      $data = $config->get(CONSUMER_KEY);
      break;
    case CONSUMER_SECRET_KEY:
      $data = $config->get(CONSUMER_SECRET_KEY);
      break;
    case CRON_TWEET_ATTEMP:
      $data = intval($config->get(CRON_TWEET_ATTEMP));
      $data = ($data == 0) ? 1 : $data;
      break;
    case CRON_TWEET_RETWEET_INTERVAL:
      $data = intval($config->get(CRON_TWEET_RETWEET_INTERVAL));
      $data = ($data == 0) ? 0 : $data * 60;
      break;
    case CRON_TWEET_MIN_INTERVAL:
      $data = intval($config->get(CRON_TWEET_MIN_INTERVAL));
      $data = ($data == 0) ? 0 : $data;
      break;
    case CRON_TWEET_MAX_INTERVAL:
      $data = intval($config->get(CRON_TWEET_MAX_INTERVAL));
      $data = ($data == 0) ? 0 : $data;
      break;
    default:
      $data = $config->get($key);
      break;
  }
  return $data;
}

function tweets_queue_node_presave(\Drupal\Core\Entity\EntityInterface $node){
  switch ($node->bundle()) {
    case 'tweet':
      $title = $node->get('title')->getValue();
      $hashtag = $node->get('field_hash_tag')->getValue();
      $node->title->value = tweets_queue_get_urls_present($title[0]['value']);
      $node->field_hash_tag->value = tweets_queue_get_urls_present($hashtag[0]['value']);
  }
}

function tweets_queue_get_urls_present($message) {
  preg_match_all('#\bhttps?://[^,\s()<>]+(?:\([\w\d]+\)|([^,[:punct:]\s]|/))#', $message, $match);
  if ($match[0][0] == '') {
    return $message;
  }
  foreach ($match[0] as $url) {
    $bit_url = tweets_queue_make_bitly_url($url, 'dsfser', 'R_5aafdd2f8d67f78150e52ffbd0613519', 'json');
    if ($bit_url) {
      $message = str_ireplace($url, $bit_url, $message);
    }
  }
  return $message;
}


function tweets_queue_make_bitly_url($url,$login,$appkey,$format = 'xml',$version = '2.0.1') {
  //create the URL
  $bitly = 'http://api.bit.ly/shorten?version='.$version.'&longUrl='.urlencode($url).'&login='.$login.'&apiKey='.$appkey.'&format='.$format;
  //get the url
  //could also use cURL here
  $response = file_get_contents($bitly);
  //parse depending on desired format
  if(strtolower($format) == 'json') {
    $json = @json_decode($response,true);
    return $json['results'][$url]['shortUrl'];
  }
  else //xml
  {
    $xml = simplexml_load_string($response);
    return 'http://bit.ly/'.$xml->results->nodeKeyVal->hash;
  }
}

/**
 * Implements hook_node_insert().
 */
function tweets_queue_node_insert(\Drupal\Core\Entity\EntityInterface $node) {
  switch ($node->bundle()) {
    case 'tweet':
      db_insert(TWEETS_PRIORITY_TABLE)
        ->fields(array(
          'nid' => $node->id(),
          'weight' => 1,
          'last_run' => 0,
        ))
        ->execute();
  }
}

/**
 * Implements hook_node_delete().
 */
function tweets_queue_node_delete(\Drupal\Core\Entity\EntityInterface $node) {
  switch ($node->bundle()) {
    case 'tweet':
    \Drupal::database()->delete(TWEETS_PRIORITY_TABLE)
        ->condition('nid', $node->id())
        ->execute();
  }
}

/**
 * Implements hook_schema().
 */
function tweets_queue_schema() {
  $schema[TWEETS_HANDLER_TABLE] = array(
    'description' => 'The base table for tweet handler specific information.',
    'fields' => array(
      'uid' => array('type' => 'int', 'not null' => TRUE),
      'status' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      CONSUMER_KEY => array('type' => 'varchar', 'length' => 100,
        'not null' => TRUE, 'default' => ''),
      CONSUMER_SECRET_KEY => array('type' => 'varchar', 'length' => 100,
        'not null' => TRUE, 'default' => ''),
      ACCESS_TOKEN => array('type' => 'varchar', 'length' => 100,
        'not null' => TRUE, 'default' => ''),
      ACCESS_SECRET_TOKEN => array('type' => 'varchar', 'length' => 100,
        'not null' => TRUE, 'default' => ''),
      'created' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'updated' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      CRON_TWEET_LAST_RUN => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      CRON_TWEET_NEXT_RUN => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      CRON_TWEET_RETWEET_INTERVAL => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
    ),
    'primary key' => array('uid'),
    'indexes' => array(
      'tweets_handler_status' => array('status'),
      'tweets_handler_updated' => array('updated'),
      'tweets_handler_next_run' => array(CRON_TWEET_NEXT_RUN),
      'tweets_handler_last_run' => array(CRON_TWEET_LAST_RUN),
      'tweets_handler_retweet_interval' => array(CRON_TWEET_RETWEET_INTERVAL),
    )
  );
  $schema[TWEETS_PRIORITY_TABLE] = array(
    'description' => 'The base table for tweet priority.',
    'fields' => array(
      'nid'       => array('type' => 'int', 'not null' => TRUE),
      'weight'    => array('type' => 'int', 'not null' => TRUE, 'default' => 1),
      'created'   => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'last_run'   => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
    ),
    'primary key' => array('nid'),
    'indexes' => array(
      'tweet_weight' => array('weight'),
      'tweet_last_run' => array('last_run')
    )
  );
  $schema[TWEETS_URL_TABLE] = array(
    'description' => 'My description',
    'fields' => array(
      'path' => array(
        'description' => 'Name of the tweet url.',
        'type' => 'varchar',
        'length' => 140,
        'not null' => TRUE,
        'default' => '',
      ),
      'api' => array(
        'description' => 'Name of the api.',
        'type' => 'varchar',
        'length' => 155,
        'not null' => TRUE,
        'default' => '',
      ),
      'last_run' => array(
        'description' => 'last run time.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0
      ),
    ),
    'primary key' => array('path', 'api'),
  );
  return $schema;
}

/**
 * Update the weight for the current tweet.
 *
 * @param integer $nid
 *   Entity nid.
 */
function tweets_queue_update_url($message) {
  preg_match_all('#\bhttps?://[^,\s()<>]+(?:\([\w\d]+\)|([^,[:punct:]\s]|/))#', $message, $match);
  if ($match[0][0] == '') {
    return;
  }
  $url = $match[0][0];
  $query = \Drupal::database()->select(TWEETS_URL_TABLE, 'p');
  $query->addField('p', 'path');
  $query->condition('p.path', $url);
  $path = $query->execute()->fetchField();

  $last_run = time();
  if ($path) {
  \Drupal::database()->update(TWEETS_URL_TABLE)
    ->condition('path', $path)
    ->fields(['last_run' => time()])
    ->execute();
  }
  else {
     db_insert(TWEETS_URL_TABLE)
        ->fields(array(
          'path' => $url,
          'api' => '',
          'last_run' => time(),
        ))
      ->execute();
  }
}

/**
 * Update the weight for the current tweet.
 *
 * @param integer $nid
 *   Entity nid.
 */
function tweets_queue_update_priority($nid) {
  tweets_queue_debug_info(t("Updating weight for :nid", array(':nid' => $nid)));
  $nid = intval($nid);
  $query = \Drupal::database()->select(TWEETS_PRIORITY_TABLE, 'p');
  $query->addField('p', 'weight');
  $query->condition('p.nid', $nid);
  $weight = $query->execute()->fetchField();
  $weight = $weight + 1;

  \Drupal::database()->update(TWEETS_PRIORITY_TABLE)
    ->condition('nid', $nid)
    ->fields(['weight' => $weight, 'last_run' => time()])
    ->execute();
  tweets_queue_debug_info(t("Updated weight for :nid to :weight",
    array(':nid' => $nid, ':weight' => $weight)));
}

/**
 * Schedule the cron run.
 *
 * @param integer $increase_cron_run_limit
 *   Whether add extra time for cron run due to duplicate tweets.
 */
function tweets_queue_schedule_cron_old($increase_cron_run_limit = 0) {
  global $base_url;
  $extend_cron_limit = ($increase_cron_run_limit) ? '&extend=1' : '';
  $path = $base_url . '/admin/structure/tweets_queue/settings?set_cron=1' . $extend_cron_limit;
  $response = new RedirectResponse($path, 302);
  $response->send();
  return;
}

/**
 * Schedule the cron run.
 *
 * @param integer $increase_cron_run_limit
 *   Whether add extra time for cron run due to duplicate tweets.
 */
function tweets_queue_schedule_cron($increase_cron_run_limit = 0) {
  $min_interval = tweets_queue_get_tweet_configuration_data(CRON_TWEET_MIN_INTERVAL);
  $max_interval = tweets_queue_get_tweet_configuration_data(CRON_TWEET_MAX_INTERVAL);
  $cron_interval = rand($min_interval, $max_interval);
  $cron_interval = $cron_interval * 60;
  \Drupal::configFactory()->getEditable('automated_cron.settings')
    ->set('interval', $cron_interval)
    ->save();

  $next_run = time() + $cron_interval;
  $config = \Drupal::service('config.factory')->getEditable('tweets_queue.settings');
  $config->set(CRON_TWEET_LAST_RUN, time())->save();
  $config->set(CRON_TWEET_NEXT_RUN, $next_run)->save();
  tweets_queue_debug_info(t('Cron scheduled for next run on :next_run',
    array(':next_run' => $next_run)));
}

/**
 * Display the debug information on the screen.
 *
 * @param string $message
 *   Message to be displayed.
 */
function tweets_queue_debug_info ($message, $repeat = TRUE) {
  $debug = tweets_queue_get_tweet_configuration_data(CRON_TWEET_DEBUG_INFO);
  if ($debug) {
    echo $message;
    drupal_set_message($message, $repeat);
  }
}

/**
 * Update tweets handler information for specific user.
 *
 * @param array $tweet_handler_info
 *   Array containing tweet handler information.
 * @param array $uid
 *   Array containing tweet handler information.
 *
 */
function tweets_queue_update_handler_info($tweet_handler_info, $uid = '') {
  $uid = (!$uid) ? \Drupal::currentUser()->id() : $uid;
  $tweet_handler_info['updated'] = time();
  $created_tweet_handler_info = $tweet_handler_info;
  $created_tweet_handler_info['created'] = time();

  db_merge(TWEETS_HANDLER_TABLE)
    ->insertFields($created_tweet_handler_info)
    ->updateFields($tweet_handler_info)
  ->key(array('uid' => $uid))
  ->execute();
}