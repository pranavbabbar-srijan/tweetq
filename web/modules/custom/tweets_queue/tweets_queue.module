<?php

/**
 * @file 
 *   To handle the custom functionality which includes -
 *   - Hooks alteration
 *   - Web services
 */

use Drupal\node\Entity\Node;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Drupal\Core\Form\ConfigFormBase;

const CONSUMER_KEY = 'consumer_key';
const CONSUMER_SECRET_KEY = 'consumer_secret_key';
const ACCESS_TOKEN = 'access_token';
const ACCESS_SECRET_TOKEN = 'access_secret_token';
const SUCCESS_MESSAGE = 'Message tweeted successfully.';
const UNSUCCESS_MESSAGE = 'Message tweet failed.';
const CRON_TWEET_ATTEMP = 'cron_tweet_attempt';
const CRON_TWEET_IMPORT_ID = 'cron_tweet_import_id';
const CRON_TWEET_IMPORT_PATH = 'cron_tweet_import_path';
const CRON_TWEET_IMPORT_FID = 'cron_tweet_import_fid';
const IMPORT_CONFIGURATION = 'import_configuration';
const TWEET_QUEUE_CSV_FILE_UPLOAD = 'tweet_queue_csv_file_upload';
const TWEET_QUEUE_CSV_FILE_UPLOAD_DIRECTORY = 'public://tweets_queue/';
const TWEETS_PRIORITY_TABLE = 'tweets_priority';
const TWEETS_URL_TABLE = 'tweets_url';
const TWEETS_HANDLER_TABLE = 'tweets_handler';
const CRON_TWEET_MIN_INTERVAL = 'cron_tweet_min_interval';
const CRON_TWEET_MAX_INTERVAL = 'cron_tweet_max_interval';
const CRON_TWEET_RETWEET_INTERVAL = 'cron_tweet_retweet_interval';
const CRON_TWEET_NEXT_RUN = 'cron_tweet_next_run';
const CRON_TWEET_LAST_RUN = 'cron_tweet_last_run';
const CRON_TWEET_DEBUG_INFO = 'cron_tweet_debug_info';
const CRON_TWEET_MESSAGES_SKIPPED = 'Tweet message skipped';
const TWITTER_HANDLER_INVALID = '2';
const TWITTER_HANDLER_VALID = '1';
const TWITTER_HANDLER_INVALID_CODE = '32';
const CRON_TWEET_CHARCATER_LIMIT = 140;


/**
 * Implements hook_form_alter().
 */
function tweets_queue_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
}

/**
 * Post the message on the twitter.
 *
 * @param string $message
 *   Message for the tweet.
 *
 * @return string
 *   Returns the tweets message.
 */
function tweets_queue_set_single_post($message = 'Good Evening!!', $twitter_handle) {
  require_once   './libraries/codebird-php/codebird.php';
  $status = array('success' => 0, 'message' => 'unsuccessful');
  $consumer_key = tweets_queue_get_client_field_info($twitter_handle, CONSUMER_KEY);
  $consumer_secret_key = tweets_queue_get_client_field_info($twitter_handle, CONSUMER_SECRET_KEY);
  $access_token = tweets_queue_get_client_field_info($twitter_handle, ACCESS_TOKEN);
  $access_secret_token = tweets_queue_get_client_field_info($twitter_handle, ACCESS_SECRET_TOKEN);

  \Codebird\Codebird::setConsumerKey($consumer_key, $consumer_secret_key);
  $cb = \Codebird\Codebird::getInstance();
  $cb->setToken($access_token, $access_secret_token);
  $params = array(
    'status' => $message
  );
  $reply = $cb->statuses_update($params);
  if (is_object($reply) && isset($reply->errors)) {
    $status['success'] = 0;
    $status['code'] = (isset($reply->errors[0]->code)) ? $reply->errors[0]->code : '';
    $status['message'] = (isset($reply->errors[0]->message)) ? $reply->errors[0]->message: 'tweet failed.';
    tweets_queue_debug_info($status['message']);
    return $status;
  }
  if (is_object($reply)) {
    $status = array('success' => 1, 'message' => 'successful');
  }
  return $status;
}

/**
 * Implements hook_cron().
 */
function tweets_queue_cron() {
  $config = \Drupal::config('tweets_queue_admin.settings');
  $current_time = time();
  $next_run = intval($config->get(CRON_TWEET_NEXT_RUN));
  if ($current_time >= $next_run) {
    tweets_queue_debug_info('Starting Cron tweet process');
    tweets_queue_compile_tweets('', TRUE);
  }
}

/**
 * Tweet the message.
 */
function tweets_queue_compile_tweets($message = '', $cron = FALSE) {
  $status = array();
  switch ($cron) {
    case TRUE:
      $status = tweets_queue_tweet_cron_message();
      break;
    case FALSE:
      $uid = \Drupal::currentUser()->id();
      $twitter_handler = tweets_queue_fetch_client_handler_info();
      $status = tweets_queue_tweet_message($message, $twitter_handler);
      if ($status['code'] == TWITTER_HANDLER_INVALID_CODE) {
        drupal_set_message(t($status['message']), 'error');
        if ($twitter_handler->status != TWITTER_HANDLER_INVALID) {
          tweets_queue_mark_handler_status($uid, TWITTER_HANDLER_INVALID);
        }
        return $status;
      }
      if ($twitter_handler->status != TWITTER_HANDLER_VALID) {
        tweets_queue_mark_handler_status($uid, TWITTER_HANDLER_VALID);
      }
      break;
  }
  switch ($status['success']) {
    case '1':
      drupal_set_message(t(SUCCESS_MESSAGE));
      break;
    case '0':
      drupal_set_message(t(UNSUCCESS_MESSAGE));
      break;
  }
}

/**
 * Tweet the message for the cron run.
 * For the cron run, messages are tried until hits max attempt.
 *
 * @return array
 *   Status for the tweet.
 */
function tweets_queue_tweet_cron_message() {
  $status = array('success' => 0);
  $handler_info = tweets_queue_fetch_all_client_handler_info();
  if ($handler_info['total'] <= 0) {
    drupal_set_message(t('There is no active handler present or tweets to be sent.'));
    return;
  }
  $tweet_max_attempt = tweets_queue_get_tweet_configuration_data(CRON_TWEET_ATTEMP);
  foreach ($handler_info['handler'] as $uid => $client_twitter_handler) {
    tweets_queue_compile_client_tweets($client_twitter_handler, $uid, $tweet_max_attempt);
  }
}

/**
 * Send message from the specific user twitter handler.
 *
 * @param object $client_twitter_handler
 *   Twitter handler.
 * @param integer $uid
 *   User uid.
 * @param integer $tweet_max_attempt
 *   Maximum tweet attempt for an user.
 *
 * @return array
 *   Returns status containing the tweets.
 */
function tweets_queue_compile_client_tweets($client_twitter_handler, $uid, $tweet_max_attempt = 3) {
  $text_size = CRON_TWEET_CHARCATER_LIMIT;
  $tweet_max_attempt = tweets_queue_get_tweet_configuration_data(CRON_TWEET_ATTEMP);
  $tweet_data = tweets_queue_get_tweets_cron_list($client_twitter_handler, $tweet_max_attempt);

  $total = count($tweet_data['nids']);
  if ($total == 0) {
    return;
  }
  
  if ($tweet_max_attempt > $total) {
    $tweet_max_attempt = $total;
  }
  drupal_set_message(t("Process for $tweet_max_attempt times."));
  tweets_queue_debug_info("Process started for $total items for uid: $uid");
  for ($attempt=0; $attempt < $tweet_max_attempt; $attempt++) {
    $nid = array_rand($tweet_data['nids'], 1);
    unset($tweet_data['nids'][$nid]);
    $message  = $tweet_data['data'][$nid]->message;
    $tweet_size = \Drupal\Component\Utility\Unicode::strlen($message);
    $weight = $tweet_data['data'][$nid]->weight + 1;
    tweets_queue_debug_info("Process progress for $nid:$message::size:$tweet_size");
    if ($tweet_size > $text_size) {
      tweets_queue_debug_info(t(':message for :nid',
        array(':message' => CRON_TWEET_MESSAGES_SKIPPED, ':nid' => $nid)));
      $priority_info = array('size' => $tweet_size);
      tweets_queue_update_priority_info($nid, $priority_info);
      continue;
    }
    tweets_queue_debug_info("Process progress for $nid:$message::size:$tweet_size");
    if (!tweets_queue_authenticate_url($message, $uid)) {
      tweets_queue_debug_info('Tweet from same article already exists.');
      tweets_queue_debug_info(t(':message for :nid',
        array(':message' => CRON_TWEET_MESSAGES_SKIPPED, ':nid' => $nid)));
      $priority_info = array('size' => $tweet_size, 'weight' => $weight);
      tweets_queue_update_priority_info($nid, $priority_info);
      continue;
    }
    tweets_queue_debug_info("Process Send started.");
    $status = tweets_queue_tweet_message($message, $client_twitter_handler);
    if ($status['code'] == TWITTER_HANDLER_INVALID_CODE) {
      tweets_queue_mark_handler_status($uid, TWITTER_HANDLER_INVALID);
      return $status;
    }
    tweets_queue_update_priority_info($nid, array(), 1);
    tweets_queue_update_url($message, $uid);
    if ($status['success']) {
      tweets_queue_mark_handler_next_run($uid);
      return $status;
    }
  }
  if ($attempt >= $tweet_max_attempt-1) {
    // tweets_queue_schedule_cron(1);
    drupal_set_message(t('Maximun tweet attempt reached.'));
  }
  return $status;
}

/**
 * Mark specific user handler next run.
 *
 * @param integer $uid
 *   User uid.
 */
function tweets_queue_mark_handler_next_run($uid) {
  if (!$uid) {
    return;
  }
  $min_interval = tweets_queue_get_tweet_configuration_data(CRON_TWEET_MIN_INTERVAL);
  $max_interval = tweets_queue_get_tweet_configuration_data(CRON_TWEET_MAX_INTERVAL);
  $cron_interval = rand($min_interval, $max_interval);
  $cron_interval = $cron_interval * 60;
  $tweet_handler_info = array(
    CRON_TWEET_NEXT_RUN =>  time() + $cron_interval,
  );
  tweets_queue_update_handler_info($tweet_handler_info, $uid);
}

/**
 * Mark specific user handler status.
 *
 * @param integer $uid
 *   User uid.
 * @param integer $status
 *   Handler status. 0=not verified, 1=verified and active, 2=invalid.
 */
function tweets_queue_mark_handler_status($uid, $status) {
  if (!$uid) {
    return;
  }
  $tweet_handler_info = array(
    'status' => $status,
  );
  tweets_queue_update_handler_info($tweet_handler_info, $uid);
  $state = array(TWITTER_HANDLER_VALID => 'active', TWITTER_HANDLER_INVALID => 'inactive');
  $message_status = array(TWITTER_HANDLER_VALID => 'status', TWITTER_HANDLER_INVALID => 'error');
  drupal_set_message(t('Twitter handler status @status marked successfully.',
    array('@status' => $state[$status])), $message_status[$status]);
}

/**
 * Test whether text contains url and passed execution time line.
 *
 * @param string $message
 * @return integer
 */
function tweets_queue_authenticate_url($message, $uid = '') {
  $tweet_allowed = 1;
  $tweet_disallowed = 0;
  preg_match_all('#\bhttps?://[^,\s()<>]+(?:\([\w\d]+\)|([^,[:punct:]\s]|/))#', $message, $match);
  if ($match[0][0] == '') {
    return $tweet_allowed;
  }
  $url = $match[0][0];
  $query = \Drupal::database()->select(TWEETS_URL_TABLE, 'p');
  $query->addField('p', 'last_run');
  $query->condition('p.path', $url);
  if ($uid) {
    $query->condition('p.api', $uid);
  }
  $last_run = $query->execute()->fetchField();
  if ($last_run == 0 or $last_run == '') {
    return $tweet_allowed;
  }
  $minimum_lapse_interval = tweets_queue_get_tweet_configuration_data(CRON_TWEET_RETWEET_INTERVAL);
  $next_reweet = $last_run + $minimum_lapse_interval;
  $now = time();
  if ($next_reweet <= $now) {
    return $tweet_allowed;;
  }
  tweets_queue_debug_info(t("Same article tweet was last run at :last_run",
    array(':last_run' => $last_run)));
  tweets_queue_debug_info(t("Next run time is :next_reweet",
    array(':next_reweet' => $next_reweet)));
  return $tweet_disallowed;
}

/**
 * Tweet the message.
 *
 * @param string $message
 *   Message to be tweeted.
 *
 * @return array
 *   Status for the tweet.
 */
function tweets_queue_tweet_message($message, $twitter_handler) {
  $status = array('success' => 0);
  if (empty($message)) {
    return $status;
  }
  try {
    $status = tweets_queue_set_single_post($message, $twitter_handler);
  }
  catch (\Exception $e) {
    \Drupal::logger('tweets_queue')->error($e->getMessage());
    drupal_set_message(t($e->getMessage()));
  }
  return $status;
}

/**
 * Get the tweet message stored in the database.
 *
 * @return string
 *   Returns the tweets message.
 */
function tweets_queue_get_tweets_cron_list($client_handler, $tweet_max_attempt = 3) {
  $nid = '';
  $message = '';
  $minimum_lapse_interval = tweets_queue_get_client_field_info($client_handler, CRON_TWEET_RETWEET_INTERVAL);
  $uid = tweets_queue_get_client_field_info($client_handler, 'uid');
  $query = \Drupal::database()->select(TWEETS_PRIORITY_TABLE, 'p');
  $query->fields('p', ['nid', 'uid', 'size', 'message', 'weight', 'created', 'last_run']);

  if ($minimum_lapse_interval > 0) {
    $minimum_lapse_time = time() - ($minimum_lapse_interval * 60);
    $db_or = db_or();
    $db_or->condition('p.last_run', '0' , '=');
    $db_or->condition('p.last_run', $minimum_lapse_time , '<=');
    $query->condition($db_or);
  }
  $query->condition('p.uid', $uid , '=');
  $query->condition('p.size', CRON_TWEET_CHARCATER_LIMIT , '<=');
  $query->orderBy('p.weight', 'ASC');
  $query->range(0, $tweet_max_attempt);
  $data = $query->execute()->fetchAll();
  $output = array('nids' => array(), 'data' => array(), 'total' => 0);
  foreach ($data as $pos => $tweet_data) {
    $output['nids'][$tweet_data->nid] = $tweet_data->nid;
    $output['data'][$tweet_data->nid] = $tweet_data;

  }
  return $output;
}

function tweets_queue_get_tweets_cron_listOld($client_handler, $tweet_max_attempt = 3) {
  $nid = '';
  $message = '';
  $minimum_lapse_interval = tweets_queue_get_client_field_info($client_handler, CRON_TWEET_RETWEET_INTERVAL);
  $uid = tweets_queue_get_client_field_info($client_handler, 'uid');
  $query = \Drupal::database()->select(TWEETS_PRIORITY_TABLE, 'p');
  $query->fields('p', ['nid']);

  if ($minimum_lapse_interval > 0) {
    $minimum_lapse_time = time() - ($minimum_lapse_interval * 60);
    $db_or = db_or();
    $db_or->condition('p.last_run', '0' , '=');
    $db_or->condition('p.last_run', $minimum_lapse_time , '<=');
    $query->condition($db_or);
  }
  $query->condition('p.uid', $uid , '=');
  $query->condition('p.size', CRON_TWEET_CHARCATER_LIMIT , '<=');
  $query->orderBy('p.weight', 'ASC');
  $query->range(0, $tweet_max_attempt);
  $nids = $query->execute()->fetchAllKeyed();
  return $nids;
}

/**
 * Load the tweet message for the tweeting.
 *
 * @param integer $nid
 *   Entity nid.
 *
 * @return string
 *   Returns the tweets message.
 */
function tweets_queue_load_tweet_message($nid = '') {
  $message = '';
  if (empty($nid)) {
    return $message;
  }
  $entity  = Node::load($nid);
  if (is_object($entity)) {
    $title = tweets_queue_load_field_info($entity, 'title');
    $body = tweets_queue_load_field_info($entity, 'body');
    $hash_tag = tweets_queue_load_field_info($entity, 'field_hash_tag');
    $message = $title . ' ' . $body . ' ' . $hash_tag;
  }
  return $message;
}

/**
 * Fetch field data from the entity..
 *
 * @param object $entity
 *   Entity object.
 *
 * @param string $field_name
 *   Name of the entity field to be read.
 *
 * @return string
 *   Returns the tweets message for the tweeting.
 */
function tweets_queue_load_field_info($entity, $field_name = 'title') {
  $output = '';
  $field_info = $entity->get($field_name)->getValue();
  if (count($field_info) > 0) {
    foreach ($field_info as $pos => $field_value) {
      $data = ($data) ? $data . ' ' . $field_value['value'] : $field_value['value'];
    }
  }
  return $data;
}

/**
 * Get tweets api configuration data.
 * This data is used to for tweets authentication.
 *
 * @param string $key
 *  Name of the tweets api configuration name.
 *
 * @return string
 *   Returns the tweets api configuration data.
 */
function tweets_queue_get_tweet_configuration_data($key = CONSUMER_KEY) {
  $config = \Drupal::config('tweets_queue_admin.settings');
  $data = '';
  switch ($key) {
    case ACCESS_TOKEN:
      $data = $config->get(ACCESS_TOKEN);
      break;
    case ACCESS_SECRET_TOKEN:
      $data = $config->get(ACCESS_SECRET_TOKEN);
      break;
    case CONSUMER_KEY:
      $data = $config->get(CONSUMER_KEY);
      break;
    case CONSUMER_SECRET_KEY:
      $data = $config->get(CONSUMER_SECRET_KEY);
      break;
    case CRON_TWEET_ATTEMP:
      $data = intval($config->get(CRON_TWEET_ATTEMP));
      $data = ($data == 0) ? 1 : $data;
      break;
    case CRON_TWEET_RETWEET_INTERVAL:
      $data = intval($config->get(CRON_TWEET_RETWEET_INTERVAL));
      $data = ($data == 0) ? 0 : $data * 60;
      break;
    case CRON_TWEET_MIN_INTERVAL:
      $data = intval($config->get(CRON_TWEET_MIN_INTERVAL));
      $data = ($data == 0) ? 0 : $data;
      break;
    case CRON_TWEET_MAX_INTERVAL:
      $data = intval($config->get(CRON_TWEET_MAX_INTERVAL));
      $data = ($data == 0) ? 0 : $data;
      break;
    default:
      $data = $config->get($key);
      break;
  }
  return $data;
}

function tweets_queue_node_presave(\Drupal\Core\Entity\EntityInterface $node){
  switch ($node->bundle()) {
    case 'tweet':
      $title = $node->get('title')->getValue();
      $hashtag = $node->get('field_hash_tag')->getValue();
      $node->title->value = tweets_queue_get_urls_present($title[0]['value']);
      $node->field_hash_tag->value = tweets_queue_get_urls_present($hashtag[0]['value']);
  }
}

function tweets_queue_get_urls_present($message) {
  preg_match_all('#\bhttps?://[^,\s()<>]+(?:\([\w\d]+\)|([^,[:punct:]\s]|/))#', $message, $match);
  if ($match[0][0] == '') {
    return $message;
  }
  foreach ($match[0] as $url) {
    $bit_url = tweets_queue_make_bitly_url($url, 'dsfser', 'R_5aafdd2f8d67f78150e52ffbd0613519', 'json');
    if ($bit_url) {
      $message = str_ireplace($url, $bit_url, $message);
    }
  }
  return $message;
}


function tweets_queue_make_bitly_url($url,$login,$appkey,$format = 'xml',$version = '2.0.1') {
  //create the URL
  $bitly = 'http://api.bit.ly/shorten?version=' . $version . '&longUrl=' . urlencode($url)
    . '&login=' . $login . '&apiKey=' . $appkey . '&format=' . $format;
  //get the url
  //could also use cURL here
  $response = file_get_contents($bitly);
  //parse depending on desired format
  if(strtolower($format) == 'json') {
    $json = @json_decode($response,true);
    return $json['results'][$url]['shortUrl'];
  }
  else //xml
  {
    $xml = simplexml_load_string($response);
    return 'http://bit.ly/'.$xml->results->nodeKeyVal->hash;
  }
}

/**
 * Implements hook_node_insert().
 */
function tweets_queue_node_insert(\Drupal\Core\Entity\EntityInterface $node) {
  switch ($node->bundle()) {
    case 'tweet':
      $tweet_size = tweets_queue_calculate_tweet_size($node);
      $priority_info = array(
        'size' => $tweet_size,
        'message' => tweets_queue_calculate_tweet_size($node, 'message'),
      );
      $update_node = \Drupal\node\Entity\Node::load($node->id());
      $update_node->set("field_size", $tweet_size);
      $update_node->save();
      tweets_queue_update_priority_info($node->id(), $priority_info);
  }
}

/**
 * Implements hook_entity_update().
 */
function tweets_queue_entity_update(Drupal\Core\Entity\EntityInterface $entity) {
  switch ($entity->bundle()) {
    case 'tweet':
      $size = tweets_queue_load_field_info($entity, 'field_size');
      $current_size = tweets_queue_calculate_tweet_size($entity);
      if ($size != $current_size) {
        $update_node = \Drupal\node\Entity\Node::load($entity->id());
        $update_node->set("field_size", $current_size);
        $update_node->save();
        $priority_info = array(
          'size' => $current_size,
          'message' => tweets_queue_calculate_tweet_size($entity, 'message'),
        );
        tweets_queue_update_priority_info($entity->id(), $priority_info);
      }
      if ($current_size > CRON_TWEET_CHARCATER_LIMIT) {
        drupal_set_message(t('This item can not be tweeted due to the tweet size limit @size_limit .',
          array('@size_limit' => CRON_TWEET_CHARCATER_LIMIT)), 'warning');
        drupal_set_message(t('Current size of the tweet item is @size',
          array('@size' => $current_size)), 'status');
        drupal_set_message(t('Please make sure to have tweet message size less than or equal
         to 140 characters for tweeting'), 'status');
      }
  }
}

/**
 * Calculate tweet size.
 *
 * @param object $node
 *   Tweet node object.
 *
 * @return integer
 *   Return size of the tweet message.
 */
function tweets_queue_calculate_tweet_size(\Drupal\Core\Entity\EntityInterface $node, $case = 'size') {
  $tweet_size = 0;
  $title = tweets_queue_load_field_info($node, 'title');
  $body = tweets_queue_load_field_info($node, 'body');
  $hash_tag = tweets_queue_load_field_info($node, 'field_hash_tag');
  $message = $title;
  if (!empty($body)) {
    $message .= ' ' . $body;
  }
  if (!empty($hash_tag)) {
    $message .= ' ' . $hash_tag;
  }
  $message = \Drupal\Component\Utility\Xss::filter($message);
  $tweet_size = \Drupal\Component\Utility\Unicode::strlen($message);
  if ($case == 'size') {
    return $tweet_size;
  }
  else {
    return $message;
  }
}

/**
 * Implements hook_node_delete().
 */
function tweets_queue_node_delete(\Drupal\Core\Entity\EntityInterface $node) {
  switch ($node->bundle()) {
    case 'tweet':
    \Drupal::database()->delete(TWEETS_PRIORITY_TABLE)
        ->condition('nid', $node->id())
        ->execute();
  }
}

/**
 * Implements hook_schema().
 */
function tweets_queue_schema() {
  $schema[TWEETS_HANDLER_TABLE] = array(
    'description' => 'The base table for tweet handler specific information.',
    'fields' => array(
      'uid' => array('type' => 'int', 'not null' => TRUE),
      'status' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      CONSUMER_KEY => array('type' => 'varchar', 'length' => 100,
        'not null' => TRUE, 'default' => ''),
      CONSUMER_SECRET_KEY => array('type' => 'varchar', 'length' => 100,
        'not null' => TRUE, 'default' => ''),
      ACCESS_TOKEN => array('type' => 'varchar', 'length' => 100,
        'not null' => TRUE, 'default' => ''),
      ACCESS_SECRET_TOKEN => array('type' => 'varchar', 'length' => 100,
        'not null' => TRUE, 'default' => ''),
      CRON_TWEET_IMPORT_FID => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'created' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'updated' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      CRON_TWEET_LAST_RUN => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      CRON_TWEET_NEXT_RUN => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      CRON_TWEET_RETWEET_INTERVAL => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
    ),
    'primary key' => array('uid'),
    'indexes' => array(
      'tweets_handler_status' => array('status'),
      'tweets_handler_updated' => array('updated'),
      'tweets_handler_next_run' => array(CRON_TWEET_NEXT_RUN),
      'tweets_handler_last_run' => array(CRON_TWEET_LAST_RUN),
      'tweets_handler_retweet_interval' => array(CRON_TWEET_RETWEET_INTERVAL),
    )
  );
  $schema[TWEETS_PRIORITY_TABLE] = array(
    'description' => 'The base table for tweet priority.',
    'fields' => array(
      'nid' => array('type' => 'int', 'not null' => TRUE),
      'uid' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'size' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'message' => array('type' => 'varchar', 'not null' => TRUE, 'length' => 954, 'default' => ''),
      'weight' => array('type' => 'int', 'not null' => TRUE, 'default' => 1),
      'created' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'last_run' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
    ),
    'primary key' => array('nid'),
    'indexes' => array(
      'tweets_priority_weight' => array('uid'),
      'tweets_priority_uid' => array('weight'),
      'tweets_priority_last_run' => array('last_run')
    )
  );
  $schema[TWEETS_URL_TABLE] = array(
    'description' => 'My description',
    'fields' => array(
      'path' => array(
        'description' => 'Name of the tweet url.',
        'type' => 'varchar',
        'length' => 140,
        'not null' => TRUE,
        'default' => '',
      ),
      'api' => array(
        'description' => 'Name of the api.',
        'type' => 'varchar',
        'length' => 155,
        'not null' => TRUE,
        'default' => '',
      ),
      'last_run' => array(
        'description' => 'last run time.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0
      ),
    ),
    'primary key' => array('path', 'api'),
  );
  return $schema;
}

/**
 * Update the weight for the current tweet.
 *
 * @param integer $nid
 *   Entity nid.
 */
function tweets_queue_update_url($message, $uid = '') {
  preg_match_all('#\bhttps?://[^,\s()<>]+(?:\([\w\d]+\)|([^,[:punct:]\s]|/))#', $message, $match);
  if ($match[0][0] == '') {
    return;
  }
  $url = $match[0][0];
  $query = \Drupal::database()->select(TWEETS_URL_TABLE, 'p');
  $query->addField('p', 'path');
  $query->condition('p.path', $url);
  $query->condition('p.api', $uid);
  $path = $query->execute()->fetchField();

  $last_run = time();
  if ($path) {
  \Drupal::database()->update(TWEETS_URL_TABLE)
    ->condition('path', $path)
    ->fields(['last_run' => time()])
    ->execute();
  }
  else {
     db_insert(TWEETS_URL_TABLE)
        ->fields(array(
          'path' => $url,
          'api' => $uid,
          'last_run' => time(),
        ))
      ->execute();
  }
}

/**
 * Update the priority table for the tweet.
 *
 * @param integer $nid
 *   Entity nid.
 * @param array $tweet_priority_info
 *   Array containing update information.
 */
function tweets_queue_update_priority_info($nid, $tweet_priority_info = array(), $cron = 0) {
  if (empty($nid)) {
    return;
  }
  $created_tweet_priority_info = array();
  if (is_array($tweet_priority_info)) {
    $created_tweet_priority_info = $tweet_priority_info;
  }
  else {
    $tweet_priority_info = array();
  }
  $created_tweet_priority_info['created'] = time();
  $created_tweet_priority_info['uid'] = \Drupal::currentUser()->id();
  $created_tweet_priority_info['weight'] = 1;
  if ($cron) {
    db_merge(TWEETS_PRIORITY_TABLE)
      ->insertFields($created_tweet_priority_info)
      ->updateFields($tweet_priority_info)
      ->key(array('nid' => $nid))
      ->expression('weight', 'weight + :inc', array(':inc' => 1))
      ->expression('last_run', time())
      ->execute();
    tweets_queue_debug_info(t("Updated weight for :nid to :weight",
      array(':nid' => $nid, ':weight' => $weight)));
  }
  else {
    db_merge(TWEETS_PRIORITY_TABLE)
      ->insertFields($created_tweet_priority_info)
      ->updateFields($tweet_priority_info)
      ->key(array('nid' => $nid))
      ->execute();
  }
}

/**
 * Schedule the cron run.
 *
 * @param integer $increase_cron_run_limit
 *   Whether add extra time for cron run due to duplicate tweets.
 */
function tweets_queue_schedule_cron_old($increase_cron_run_limit = 0) {
  global $base_url;
  $extend_cron_limit = ($increase_cron_run_limit) ? '&extend=1' : '';
  $path = $base_url . '/admin/structure/tweets_queue/settings?set_cron=1' . $extend_cron_limit;
  $response = new RedirectResponse($path, 302);
  $response->send();
  return;
}

/**
 * Schedule the cron run.
 *
 * @param integer $increase_cron_run_limit
 *   Whether add extra time for cron run due to duplicate tweets.
 */
function tweets_queue_schedule_cron($increase_cron_run_limit = 0) {
  $min_interval = tweets_queue_get_tweet_configuration_data(CRON_TWEET_MIN_INTERVAL);
  $max_interval = tweets_queue_get_tweet_configuration_data(CRON_TWEET_MAX_INTERVAL);
  $cron_interval = rand($min_interval, $max_interval);
  $cron_interval = $cron_interval * 60;
  \Drupal::configFactory()->getEditable('automated_cron.settings')
    ->set('interval', $cron_interval)
    ->save();

  $next_run = time() + $cron_interval;
  $config = \Drupal::service('config.factory')->getEditable('tweets_queue.settings');
  $config->set(CRON_TWEET_LAST_RUN, time())->save();
  $config->set(CRON_TWEET_NEXT_RUN, $next_run)->save();
  tweets_queue_debug_info(t('Cron scheduled for next run on :next_run',
    array(':next_run' => $next_run)));
}

/**
 * Display the debug information on the screen.
 *
 * @param string $message
 *   Message to be displayed.
 */
function tweets_queue_debug_info ($message, $repeat = TRUE) {
  $debug = tweets_queue_get_tweet_configuration_data(CRON_TWEET_DEBUG_INFO);
  if ($debug) {
    echo $message;
    drupal_set_message($message, $repeat);
  }
}

/**
 * Update tweets handler information for specific user.
 *
 * @param array $tweet_handler_info
 *   Array containing tweet handler information.
 * @param array $uid
 *   Array containing tweet handler information.
 *
 */
function tweets_queue_update_handler_info($tweet_handler_info, $uid = '') {
  $uid = (!$uid) ? \Drupal::currentUser()->id() : $uid;
  $tweet_handler_info['updated'] = time();
  $created_tweet_handler_info = $tweet_handler_info;
  $created_tweet_handler_info['created'] = time();

  db_merge(TWEETS_HANDLER_TABLE)
    ->insertFields($created_tweet_handler_info)
    ->updateFields($tweet_handler_info)
  ->key(array('uid' => $uid))
  ->execute();
  drupal_set_message(t('Twitter handler configuration saved successfully.'));
}

/**
 * fetch tweets handler information for specific user.
 *
 * @param array $tweet_handler_info
 *   Array containing tweet handler information.
 * @param array $uid
 *   Array containing tweet handler information.
 *
 * @return object
 *   Returns twitter handler specific information.
 */
function tweets_queue_fetch_client_handler_info($uid = '') {
  $uid = (!$uid) ? \Drupal::currentUser()->id() : $uid;
  
  $query = \Drupal::database()->select(TWEETS_HANDLER_TABLE, 'p');
  $query->fields('p', ['uid', 'status', 'created','updated', 'consumer_key',
    'consumer_secret_key', 'access_token', 'access_secret_token', 'cron_tweet_last_run',
    'cron_tweet_next_run', 'cron_tweet_retweet_interval', 'cron_tweet_import_fid']);
  $query->condition('p.uid', $uid , '=');
  $data = $query->execute()->fetchObject();
  return $data;
}

/**
 * Get twitter handler specific field information.
 *
 * @param object $data
 *   Contains client handler information.
 * @param string $field_name
 *   Name of the twitter handler field.
 *
 * @return string
 *   Returns handler specific field information.
 */
function tweets_queue_get_client_field_info($data, $field_name) {
  $field_value = '';
  if (is_object($data) && isset($data->{$field_name})) {
    $field_value = $data->{$field_name};
  }
  return $field_value;
}

/**
 * fetch tweets handler information for specific user.
 *
 * @param array $tweet_handler_info
 *   Array containing tweet handler information.
 * @param array $uid
 *   Array containing tweet handler information.
 *
 * @return object
 *   Returns twitter handler specific information.
 */
function tweets_queue_fetch_all_client_handler_info() {
  $query = \Drupal::database()->select(TWEETS_HANDLER_TABLE, 'p');
  $query->fields('p', ['uid', 'status', 'created','updated', 'consumer_key',
    'consumer_secret_key', 'access_token', 'access_secret_token', 'cron_tweet_last_run',
    'cron_tweet_next_run', 'cron_tweet_retweet_interval']);
  $time = time();
  $db_or = db_or();
  $db_or->condition('p.cron_tweet_next_run', '0' , '=');
  $db_or->condition('p.cron_tweet_next_run', $time , '<=');
  $query->condition($db_or);

  // Only bring active handlers.
  $query->condition('p.status', array('0', '1') , 'IN');

  $data = $query->execute()->fetchAll();
  $result = array('total' => 0);
  $total = 0;
  foreach ($data as $pos => $handler_object) {
    $total++;
    $result['handler'][$handler_object->uid] = $handler_object;
  }
  $result['total'] = $total;
  return $result;
}

/**
 * Mark all the priority items which are not yet have size defined.
 *
 */
function tweets_queue_update_tweet_priority_mark_item_size() {
  $query = \Drupal::database()->select(TWEETS_PRIORITY_TABLE, 'p');
  $query->fields('p', ['nid', 'size', 'uid']);
  $query->condition('p.size', '0' , '=');
  $data = $query->execute()->fetchAll();
  $result = array('total' => 0);
  $total = 0;
  foreach ($data as $pos => $tweet_object) {
    $entity  = Node::load($tweet_object->nid);
    $message  = tweets_queue_calculate_tweet_size($entity, 'message');
    $tweet_size = tweets_queue_calculate_tweet_size($entity);
    $priority_info = array(
      'size' => $tweet_size,
      'message' => $message,
    );
    tweets_queue_update_priority_info($tweet_object->nid, $priority_info);
    $total++;
  }
  drupal_set_message(t('Total @total items updated with their tweet size.',
    array('@total' => $total)));
}